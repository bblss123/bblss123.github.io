---
layout: post
title:  "关于分块"
desc: "一些关于分块的感想以及一些题目"
keywords: "mess"
date: 2016-08-31
categories: [OI]
tags: [blog]
icon: fa-bookmark-o
---

众所周知，分块是一种神奇的东西，在关键时刻可以怒踩标程。ZJ省队也有一位先辈，以善于在标程的复杂度上套一个$\sqrt{\ \ } $并且怒踩标程而出名(扯淡结束)，最近刷了一些让人颇有感触的分块题，于是口胡一下。

# [CodeChef Nov14 FNCS](https://www.codechef.com/NOV14/problems/FNCS)

## Description:

​	一个n个元素的数组A[]，有n个函数，每个函数对应一个区间$[L_i,R_i]$,函数的值为$\sum_{i=L_i}^{R_i}A[i]$，现有q个操作，每次更改一个元素的值或者询问一段函数的值的和。

## Solution:

​	感觉非常像树套树啊。。然而如果作为树套树恐惧症的患者，其实可以用不仅编程复杂度更低，时间复杂度也较低的分块来解决。

​	首先你要明确，CodeChef上空间是不设限的(当然你开大个几百倍基本上得RE(Other)，再大的话没的说得CE)，那么我们开始分块之旅。

​	对函数进行分块。记录每个元素在一个块中出现的次数。

​	那么单点更新的时候我们就可以在$\sqrt{n}$的时间里更新每个块的值了。

​	还有就是如果有一些函数需要单独算(不在块内)，我们可以维护一个BIT，然后log(n)暴力算。

​	剩下就只有一个问题了:如何得到每个元素在块中出现的次数。

​	这很无脑，差分即可。

​	那么我们把块的个数设到$\sqrt{nlog(n)}$，总的复杂度就可以达到$O(n \sqrt{nlog(n)})$了

​	感觉空间有点大有点虚所以我的阈值只设到了$O(\sqrt{n})$，然而还是过了。。

# Code

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<string.h>
#include<math.h>
using namespace std;
#define debug(x) cout<<#x<<"="<<x<<" ";
#define debugm(x) cout<<#x<<"="<<x<<endl;
#define line puts("---------------");
typedef unsigned long long ll;
const int M=1e5+5;
int cnt[M][340],w[M][340],l[M],r[M],A[M];
inline void rd(int &a){
	a=0;char c;
	while(c=getchar(),!isdigit(c));
	do a=a*10+(c^48);
		while(c=getchar(),isdigit(c));
}
ll sum[M];
int n,q;
inline void nt(ll x){
	if(!x)return;
	nt(x/10);
	putchar(x%10+48);
}
void pt(ll x){
	if(!x)putchar('0');
	else nt(x);
}
struct BIT{
	ll bit[M];
	inline void add(int x,int a){
		for(;x<=n;x+=x&-x)
			bit[x]+=a;
	}
	inline ll sum(int x){
		ll res=0;
		for(;x;x-=x&-x)
			res+=bit[x];
		return res;
	}
	inline ll query(int l,int r){
		return sum(r)-sum(l-1);
	}
}T;
int main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		rd(A[i]);
		T.add(i,A[i]);
	}
	int S=(int)sqrt(n+1)+1;
	for(int i=0;i<n;++i){
		rd(l[i]),rd(r[i]);
		int s=i/S;
		w[l[i]][s]++;w[r[i]+1][s]--;
	}
	for(int i=0;i*S<n;++i){
		int s=0;
		ll t=0;
		for(int j=1;j<=n;++j){
			s+=w[j][i];
			cnt[j][i]=s;
			t+=1ll*s*A[j];
		}
		sum[i]=t;
	}
	cin>>q;
	for(int opt,x,y;q--;){
		rd(opt),rd(x),rd(y);
		if(opt==1){
			for(int j=0;j*S<n;++j)
				sum[j]+=1ll*(y-A[x])*cnt[x][j];
			T.add(x,y-A[x]);
			A[x]=y;
		}
		else{
			--x,--y;
			int lt=x/S,rt=y/S;
			ll res=0;
			if(lt==rt){
				for(int i=x;i<=y;++i)
					res+=T.query(l[i],r[i]);
			}
			else{
				for(int i=x;i<(lt+1)*S;++i)
					res+=T.query(l[i],r[i]);
				for(int i=lt+1;i<rt;++i)
					res+=sum[i];
				for(int i=rt*S;i<=y;++i)
					res+=T.query(l[i],r[i]);
			}
			pt(res);putchar('\n');
		}
	}
	return 0;
} 
```

